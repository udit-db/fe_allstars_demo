#!/bin/bash

set -e

# Check for --auto-close flag and temp file
AUTO_CLOSE=false
TEMP_FILE=""
if [ "$1" = "--auto-close" ]; then
    AUTO_CLOSE=true
    TEMP_FILE="$2"
fi

# Function to signal completion on exit
cleanup() {
    if [ "$AUTO_CLOSE" = true ] && [ -n "$TEMP_FILE" ]; then
        echo "setup_complete" > "$TEMP_FILE"
    fi
}

# Set trap to call cleanup on exit
if [ "$AUTO_CLOSE" = true ]; then
    trap cleanup EXIT
fi

echo "🚀 Databricks App Template Setup"
echo "================================="

# Get the directory of this script
SETUP_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source shared utilities
source "$SETUP_DIR/setup_utils/utils.sh"

# Check for required tools
echo ""
echo "🔧 Checking System Dependencies"
echo "================================"
echo ""

OS=$(get_os)
echo "🖥️  Detected OS: $OS"
echo ""

# Check dependencies in the right order
echo "🍺 Checking Homebrew (macOS only)..."
if ! source "$SETUP_DIR/setup_utils/check_homebrew.sh" && check_homebrew; then
    exit 1
fi

echo ""
echo "📝 Checking Git..."
if ! source "$SETUP_DIR/setup_utils/check_git.sh" && check_git; then
    exit 1
fi

echo ""
echo "📦 Checking uv (Python package manager)..."
if ! source "$SETUP_DIR/setup_utils/check_uv.sh" && check_uv; then
    exit 1
fi


echo ""
echo "🚀 Checking Bun (JavaScript package manager)..."
if ! source "$SETUP_DIR/setup_utils/check_bun.sh" && check_bun; then
    exit 1
fi

echo ""
echo "🟢 Checking Node.js 18+..."
if ! source "$SETUP_DIR/setup_utils/check_node.sh" && check_node; then
    exit 1
fi

echo ""
echo "🔧 Checking Databricks CLI..."
if ! source "$SETUP_DIR/setup_utils/check_databricks.sh" && check_databricks; then
    exit 1
fi

echo ""
echo "🎉 All required system dependencies are installed!"
echo ""

# Function to prompt for input with default value
prompt_with_default() {
    local prompt="$1"
    local default="$2"
    local var_name="$3"
    
    read -p "$prompt [$default]: " input
    if [ -z "$input" ]; then
        input="$default"
    fi
    
    # Set the variable dynamically
    eval "$var_name='$input'"
}

# Function to update or add a value in .env.local
update_env_value() {
    local key="$1"
    local value="$2"
    local comment="$3"
    
    if grep -q "^${key}=" .env.local 2>/dev/null; then
        # Update existing value
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS sed
            sed -i '' "s|^${key}=.*|${key}=${value}|" .env.local
        else
            # Linux sed
            sed -i "s|^${key}=.*|${key}=${value}|" .env.local
        fi
    else
        # Add new value with comment if provided
        if [ -n "$comment" ]; then
            echo "" >> .env.local
            echo "# $comment" >> .env.local
        fi
        echo "${key}=${value}" >> .env.local
    fi
}

# Function to test databricks connection
test_databricks_connection() {
    local profile="$1"
    echo "🔍 Testing Databricks connection..."
    
    # Ensure environment variables are exported for databricks CLI
    if [ -n "$DATABRICKS_HOST" ] && [ -n "$DATABRICKS_TOKEN" ]; then
        export DATABRICKS_HOST
        export DATABRICKS_TOKEN
    fi
    
    if [ -n "$profile" ]; then
        if databricks current-user me --profile "$profile" >/dev/null 2>&1; then
            echo "✅ Successfully connected to Databricks with profile '$profile'"
            return 0
        else
            echo "❌ Failed to connect to Databricks with profile '$profile'"
            return 1
        fi
    else
        if databricks current-user me >/dev/null 2>&1; then
            echo "✅ Successfully connected to Databricks"
            return 0
        else
            echo "❌ Failed to connect to Databricks"
            return 1
        fi
    fi
}

# Check if .env.local already exists
if [ -f ".env.local" ]; then
    echo "📋 Found existing .env.local file."
    read -p "Do you want to update it? (y/N): " update_env
    if [[ ! "$update_env" =~ ^[Yy]$ ]]; then
        echo "Skipping environment configuration."
        skip_env=true
    fi
fi

if [ "$skip_env" != "true" ]; then
    echo "⚙️  Setting up environment variables..."
    
    # Load existing values if they exist
    if [ -f ".env.local" ]; then
        source .env.local 2>/dev/null || true
    fi
    
    # Initialize .env.local file if it doesn't exist
    if [ ! -f ".env.local" ]; then
        echo "# Databricks App Configuration" > .env.local
        echo "# Generated by setup script on $(date)" >> .env.local
        echo "" >> .env.local
    fi
    
    # Databricks Authentication Configuration
    echo ""
    echo "🔐 Databricks Authentication"
    echo "-----------------------------"
    echo "Choose authentication method:"
    echo "1. Personal Access Token (PAT)"
    echo "2. Configuration Profile"
    echo ""
    
    # Pre-select based on existing configuration
    if [ "$DATABRICKS_AUTH_TYPE" = "pat" ]; then
        default_choice="1"
    elif [ "$DATABRICKS_AUTH_TYPE" = "databricks-cli" ]; then
        default_choice="2"
    else
        default_choice=""
    fi
    
    if [ -n "$default_choice" ]; then
        prompt_with_default "Select option" "$default_choice" "auth_choice"
    else
        read -p "Select option (1 or 2): " auth_choice
    fi
    
    if [ "$auth_choice" = "1" ]; then
        # PAT Authentication
        echo ""
        echo "📝 Personal Access Token Setup"
        echo "-------------------------------"
        
        # Update auth type in .env.local
        update_env_value "DATABRICKS_AUTH_TYPE" "pat" "Databricks Authentication Type"
        
        if [ -z "$DATABRICKS_HOST" ]; then
            prompt_with_default "Databricks Host" "https://your-workspace.cloud.databricks.com" "DATABRICKS_HOST"
        else
            prompt_with_default "Databricks Host" "$DATABRICKS_HOST" "DATABRICKS_HOST"
        fi
        
        # Update host in .env.local
        update_env_value "DATABRICKS_HOST" "$DATABRICKS_HOST" "Databricks Configuration (PAT mode)"
        
        if [ -n "$DATABRICKS_TOKEN" ]; then
            echo "Found existing token: ${DATABRICKS_TOKEN:0:10}... (truncated)"
            read -p "Use existing token? (y/N): " use_existing
            if [[ ! "$use_existing" =~ ^[Yy]$ ]]; then
                DATABRICKS_TOKEN=""
            fi
        fi
        
        if [ -z "$DATABRICKS_TOKEN" ]; then
            echo ""
            echo "You can create a Personal Access Token here:"
            echo "📖 $DATABRICKS_HOST/settings/user/developer/access-tokens"
            echo ""
            read -s -p "Databricks Personal Access Token: " DATABRICKS_TOKEN
            echo ""
        fi
        
        # Update token in .env.local
        update_env_value "DATABRICKS_TOKEN" "$DATABRICKS_TOKEN"
        
        # Set empty profile to indicate PAT mode
        DATABRICKS_CONFIG_PROFILE=""
        DATABRICKS_AUTH_TYPE="pat"
        
        # Test PAT authentication
        echo "🔍 Testing PAT authentication..."
        export DATABRICKS_HOST="$DATABRICKS_HOST"
        export DATABRICKS_TOKEN="$DATABRICKS_TOKEN"
        
        echo "Attempting to connect with:"
        echo "Host: $DATABRICKS_HOST"
        echo "Token: ${DATABRICKS_TOKEN:0:10}... (truncated)"
        echo ""
        
        # Test connection and show output for debugging
        echo "Running: databricks current-user me"
        # Export for databricks CLI
        export DATABRICKS_HOST="$DATABRICKS_HOST"
        export DATABRICKS_TOKEN="$DATABRICKS_TOKEN"
        if databricks current-user me >/dev/null 2>&1; then
            echo "✅ Successfully connected to Databricks with PAT"
        else
            echo ""
            echo "❌ PAT authentication failed."
            echo "Please check your host URL and token are correct."
            echo "You can test manually with:"
            echo "DATABRICKS_HOST='$DATABRICKS_HOST' DATABRICKS_TOKEN='$DATABRICKS_TOKEN' databricks current-user me"
            exit 1
        fi
        
    elif [ "$auth_choice" = "2" ]; then
        # Profile Authentication
        echo ""
        echo "📋 Configuration Profile Setup"
        echo "-------------------------------"
        
        # Update auth type in .env.local
        update_env_value "DATABRICKS_AUTH_TYPE" "databricks-cli" "Databricks Authentication Type"
        
        # List existing profiles
        printf "Loading profiles... "
        PROFILES_OUTPUT=$(databricks auth profiles 2>/dev/null)
        printf "✓\n"
        if [ $? -eq 0 ] && [ -n "$PROFILES_OUTPUT" ]; then
            echo "$PROFILES_OUTPUT"
        else
            echo "No existing profiles found"
        fi
        echo ""
        
        prompt_with_default "Databricks Config Profile" "${DATABRICKS_CONFIG_PROFILE:-DEFAULT}" "DATABRICKS_CONFIG_PROFILE"
        
        # Update profile in .env.local
        update_env_value "DATABRICKS_CONFIG_PROFILE" "$DATABRICKS_CONFIG_PROFILE" "Databricks Configuration (Profile mode)"
        
        # Clear PAT credentials when using profile
        update_env_value "DATABRICKS_HOST" ""
        update_env_value "DATABRICKS_TOKEN" ""
        DATABRICKS_HOST=""
        DATABRICKS_TOKEN=""
        DATABRICKS_AUTH_TYPE="databricks-cli"
        
        # Test profile authentication
        if ! test_databricks_connection "$DATABRICKS_CONFIG_PROFILE"; then
            echo ""
            echo "Profile '$DATABRICKS_CONFIG_PROFILE' not found or invalid."
            echo "Would you like to login to this profile now? (y/N)"
            read -p "> " login_profile
            
            if [[ "$login_profile" =~ ^[Yy]$ ]]; then
                echo "Running 'databricks auth login --profile $DATABRICKS_CONFIG_PROFILE'..."
                databricks auth login --profile "$DATABRICKS_CONFIG_PROFILE"
                
                # Test again after login
                if ! test_databricks_connection "$DATABRICKS_CONFIG_PROFILE"; then
                    echo "❌ Profile login failed or connection test failed. Please check your settings."
                    exit 1
                else
                    echo "✅ Successfully logged in to profile '$DATABRICKS_CONFIG_PROFILE'"
                fi
            else
                echo "❌ Valid Databricks authentication is required for deployment."
                exit 1
            fi
        fi
        
    else
        echo "❌ Invalid option. Please run setup again."
        exit 1
    fi
    
    # Get current user information (only if we don't have existing DBA_SOURCE_CODE_PATH)
    if [ -z "$DBA_SOURCE_CODE_PATH" ]; then
        echo ""
        echo "🔍 Getting user information..."
        
        if [ "$DATABRICKS_AUTH_TYPE" = "databricks-cli" ]; then
            DATABRICKS_USER=$(databricks current-user me --profile "$DATABRICKS_CONFIG_PROFILE" --output json 2>/dev/null | grep -o '"userName":"[^"]*"' | cut -d'"' -f4)
        else
            # For PAT auth, ensure environment variables are exported
            export DATABRICKS_HOST="$DATABRICKS_HOST"
            export DATABRICKS_TOKEN="$DATABRICKS_TOKEN"
            DATABRICKS_USER=$(databricks current-user me --output json 2>/dev/null | grep -o '"userName":"[^"]*"' | cut -d'"' -f4)
        fi
        
        if [ -n "$DATABRICKS_USER" ]; then
            echo "✅ Detected user: $DATABRICKS_USER"
        else
            echo "⚠️  Could not detect user, will use default email"
        fi
    else
        echo ""
        echo "✅ Using existing configuration from .env.local"
    fi
    
    # App Configuration
    echo ""
    echo "🚀 App Configuration"
    echo "--------------------"
    echo "If you haven't created a Databricks App yet, don't worry - the deploy script will create it for you!"
    echo "You can also create a custom app manually from the UI if you prefer:"
    
    # Get workspace URL based on auth type
    if [ "$DATABRICKS_AUTH_TYPE" = "databricks-cli" ] && [ -n "$DATABRICKS_CONFIG_PROFILE" ]; then
        WORKSPACE_HOST=$(databricks auth profiles 2>/dev/null | grep "^$DATABRICKS_CONFIG_PROFILE " | awk '{print $2}')
    elif [ "$DATABRICKS_AUTH_TYPE" = "pat" ] && [ -n "$DATABRICKS_HOST" ]; then
        WORKSPACE_HOST="$DATABRICKS_HOST"
    fi
    
    if [ -n "$WORKSPACE_HOST" ]; then
        echo "📖 $WORKSPACE_HOST/apps/create"
    else
        echo "📖 https://your-workspace.cloud.databricks.com/apps/create"
    fi
    echo ""
    prompt_with_default "App Name for Deployment" "${DATABRICKS_APP_NAME:-my-databricks-app}" "DATABRICKS_APP_NAME"
    
    # Update the default source path to use the chosen app name
    if [ -z "$DBA_SOURCE_CODE_PATH" ]; then
        if [ -n "$DATABRICKS_USER" ]; then
            DEFAULT_SOURCE_PATH="/Workspace/Users/$DATABRICKS_USER/$DATABRICKS_APP_NAME"
        else
            DEFAULT_SOURCE_PATH="/Workspace/Users/<your-email@company.com>/$DATABRICKS_APP_NAME"
        fi
    else
        DEFAULT_SOURCE_PATH="$DBA_SOURCE_CODE_PATH"
    fi
    
    prompt_with_default "Source Code Path for Deployment" "$DEFAULT_SOURCE_PATH" "DBA_SOURCE_CODE_PATH"
    
    # Update app configuration in .env.local
    update_env_value "DATABRICKS_APP_NAME" "$DATABRICKS_APP_NAME" "Databricks App Configuration"
    update_env_value "DBA_SOURCE_CODE_PATH" "$DBA_SOURCE_CODE_PATH"
    
    echo ""
    echo "✅ Environment configuration saved to .env.local"
fi

# Install Python dependencies
echo "📦 Installing Python dependencies..."
uv sync --dev

# Install frontend dependencies
echo "📦 Installing frontend dependencies..."
if command -v bun >/dev/null 2>&1; then
    cd client
    bun install
    cd ..
    echo "✅ Frontend dependencies installed successfully!"
else
    echo ""
    echo "❌ Bun is not installed, but it's required to install frontend dependencies."
    echo "📋 Frontend dependencies are essential for this project to work properly."
    echo ""
    read -p "🤔 Would you like me to install Bun for you now? (y/N): " install_bun
    
    if [[ "$install_bun" =~ ^[Yy]$ ]]; then
        echo "🚀 Installing Bun..."
        if [[ "$OS" == "macOS" ]]; then
            if command -v brew >/dev/null 2>&1; then
                brew tap oven-sh/bun && brew install bun
            else
                curl -fsSL https://bun.sh/install | bash
            fi
        else
            curl -fsSL https://bun.sh/install | bash
        fi
        
        # Source shell configuration to update PATH
        if [ -f "$HOME/.bashrc" ]; then
            source "$HOME/.bashrc"
        fi
        if [ -f "$HOME/.zshrc" ]; then
            source "$HOME/.zshrc"
        fi
        export PATH="$HOME/.bun/bin:$PATH"
        
        # Verify installation and install dependencies
        if command -v bun >/dev/null 2>&1; then
            echo "✅ Bun installed successfully!"
            cd client
            bun install
            cd ..
            echo "✅ Frontend dependencies installed successfully!"
        else
            echo "❌ Failed to install Bun. Please install it manually and re-run this script."
            echo "Visit: https://bun.sh/docs/installation"
            exit 1
        fi
    else
        echo "❌ Cannot proceed without Bun. Frontend dependencies are required."
        echo "💡 Install Bun manually and re-run this setup script:"
        echo "   curl -fsSL https://bun.sh/install | bash"
        echo "   ./setup.sh"
        exit 1
    fi
fi

# Install Playwright browsers (if Playwright is in dependencies)
echo ""
echo "🎭 Installing Playwright browsers..."
if [ -f "client/package.json" ] && grep -q "@playwright/test" client/package.json; then
    echo "📋 Found Playwright in client dependencies, installing browsers..."
    cd client
    if npx playwright install; then
        echo "✅ Playwright browsers installed successfully!"
    else
        echo "⚠️  Failed to install Playwright browsers. You can install them later with:"
        echo "   cd client && npx playwright install"
    fi
    cd ..
elif [ -f "package.json" ] && grep -q "@playwright/test" package.json; then
    echo "📋 Found Playwright in root dependencies, installing browsers..."
    if npx playwright install; then
        echo "✅ Playwright browsers installed successfully!"
    else
        echo "⚠️  Failed to install Playwright browsers. You can install them later with:"
        echo "   npx playwright install"
    fi
else
    echo "💡 Playwright not found in dependencies - browsers not installed"
    echo "   If you add Playwright later, run: npx playwright install"
fi

echo ""
echo "🎉 Setup complete!"
echo ""
echo "⚠️  IMPORTANT: Please restart Claude Code to enable MCP Playwright integration"
echo ""
echo "Next steps:"
echo "1. Restart Claude Code (close and reopen the application)"
echo "2. Run './watch.sh' to start the development servers"
echo "3. Open http://localhost:3000 to view the app"
echo "4. Open http://localhost:8000/docs to view the API documentation"
echo ""
echo "Optional:"
echo "- Run './fix.sh' to format your code"
echo "- Edit .env.local to update configuration"

# Auto-close terminal if flag is set
if [ "$AUTO_CLOSE" = true ]; then
    echo ""
    echo "Press Enter to close this terminal..."
    read
    
    # Only attempt to close on macOS where osascript is available
    if command -v osascript >/dev/null 2>&1; then
        # Close appropriate terminal app
        if [ -d "/Applications/iTerm.app" ]; then
            # For iTerm, close the current window
            osascript -e 'tell application "iTerm" to close current window' 2>/dev/null || true
        elif [ -d "/Applications/Terminal.app" ]; then
            # For Terminal, close windows containing setup.sh
            osascript -e 'tell application "Terminal" to close (every window whose name contains "setup.sh")' 2>/dev/null || true
        fi
    fi
fi

